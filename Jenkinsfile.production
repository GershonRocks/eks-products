#!/usr/bin/env groovy

/**
 * EKS Products CI/CD Pipeline
 * Comprehensive pipeline for Maven build, Docker containerization, 
 * security scanning, and deployment to EKS via ArgoCD
 */

pipeline {
    agent any
    
    // Environment variables with your specific values
    environment {
        // AWS Configuration
        AWS_DEFAULT_REGION = 'us-east-1'
        AWS_ACCOUNT_ID = '720184961863'
        ECR_REGISTRY = '720184961863.dkr.ecr.us-east-1.amazonaws.com'
        ECR_REPOSITORY = 'eks-products'
        
        // Build Configuration
        DOCKER_BUILDKIT = '1'
        MAVEN_OPTS = '-Xmx2048m -XX:MaxPermSize=512m'
        JAVA_HOME = '/usr/lib/jvm/java-21-openjdk-amd64'
        
        // Application Configuration
        APP_NAME = 'eks-products'
        APP_VERSION = "${BUILD_NUMBER}"
        HELM_CHART_PATH = 'helm/eks-products'
        
        // ArgoCD Configuration  
        ARGOCD_SERVER = 'a63fcb8006e954365acf09db02370924-1782938217.us-east-1.elb.amazonaws.com'
        ARGOCD_NAMESPACE = 'argocd'
        
        // Kubernetes Configuration
        K8S_CLUSTER_NAME = 'eks-products-cluster'
        K8S_NAMESPACE_PROD = 'production'
        K8S_NAMESPACE_DEV = 'development'
        
        // Build metadata
        GIT_COMMIT_SHORT = "${GIT_COMMIT[0..7]}"
        BUILD_TIMESTAMP = "${new Date().format('yyyy-MM-dd-HH-mm')}"
        IMAGE_TAG = "${BRANCH_NAME}-${BUILD_NUMBER}-${GIT_COMMIT_SHORT}"
    }
    
    // Build parameters
    parameters {
        choice(
            name: 'DEPLOY_ENVIRONMENT',
            choices: ['development', 'production'],
            description: 'Target deployment environment'
        )
        booleanParam(
            name: 'SKIP_TESTS',
            defaultValue: false,
            description: 'Skip unit and integration tests'
        )
        booleanParam(
            name: 'FORCE_DEPLOY',
            defaultValue: false,
            description: 'Force deployment even if tests fail'
        )
        booleanParam(
            name: 'SKIP_SECURITY_SCAN',
            defaultValue: false,
            description: 'Skip security scanning (Snyk, OWASP)'
        )
    }
    
    // Pipeline options
    options {
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timeout(time: 60, unit: 'MINUTES')
        ansiColor('xterm')
        timestamps()
        skipDefaultCheckout()
    }
    
    // Build triggers
    triggers {
        // Poll SCM every 5 minutes
        pollSCM('H/5 * * * *')
        // GitHub webhook trigger
        githubPush()
    }
    
    stages {
        stage('üîç Checkout & Setup') {
            steps {
                script {
                    // Clean workspace
                    cleanWs()
                    
                    // Checkout code
                    checkout scm
                    
                    // Set build description
                    currentBuild.description = "Branch: ${BRANCH_NAME} | Environment: ${params.DEPLOY_ENVIRONMENT}"
                    
                    // Print environment info
                    echo """
                    üöÄ Starting EKS Products Pipeline
                    ================================
                    Branch: ${BRANCH_NAME}
                    Commit: ${GIT_COMMIT_SHORT}
                    Build: ${BUILD_NUMBER}
                    Environment: ${params.DEPLOY_ENVIRONMENT}
                    Image Tag: ${IMAGE_TAG}
                    AWS Account: ${AWS_ACCOUNT_ID}
                    ECR Repository: ${ECR_REGISTRY}/${ECR_REPOSITORY}
                    ================================
                    """
                }
            }
        }
        
        stage('üèóÔ∏è Maven Build & Test') {
            when {
                not { params.SKIP_TESTS }
            }
            tools {
                maven 'Maven-3.9'
                jdk 'OpenJDK-21'
            }
            steps {
                script {
                    echo "üèóÔ∏è Building and testing with Maven..."
                    
                    // Clean and compile
                    sh 'mvn clean compile -DskipTests=true'
                    
                    // Run tests
                    sh 'mvn test'
                    
                    // Package application
                    sh 'mvn package -DskipTests=true'
                }
            }
            post {
                always {
                    // Publish test results
                    publishTestResults testResultsPattern: 'target/surefire-reports/*.xml'
                    
                    // Archive artifacts
                    archiveArtifacts artifacts: 'target/*.jar', fingerprint: true
                }
            }
        }
        
        stage('üìä Code Quality Analysis') {
            parallel {
                stage('SonarQube Analysis') {
                    when {
                        // Only run on main branch or pull requests
                        anyOf {
                            branch 'main'
                            changeRequest()
                        }
                    }
                    steps {
                        script {
                            echo "üìä Running SonarQube analysis..."
                            
                            // Run SonarQube analysis if token is available
                            try {
                                withCredentials([string(credentialsId: 'sonar-token', variable: 'SONAR_TOKEN')]) {
                                    sh '''
                                        mvn sonar:sonar \
                                        -Dsonar.token=$SONAR_TOKEN \
                                        -Dsonar.host.url=https://sonarcloud.io \
                                        -Dsonar.projectKey=eks-products \
                                        -Dsonar.organization=gershonrocks
                                    '''
                                }
                            } catch (Exception e) {
                                echo "‚ö†Ô∏è SonarQube analysis skipped: ${e.getMessage()}"
                            }
                        }
                    }
                }
                
                stage('JaCoCo Coverage') {
                    steps {
                        script {
                            echo "üìà Generating code coverage report..."
                            sh 'mvn jacoco:report'
                        }
                    }
                    post {
                        always {
                            // Publish coverage reports
                            publishHTML([
                                allowMissing: false,
                                alwaysLinkToLastBuild: true,
                                keepAll: true,
                                reportDir: 'target/site/jacoco',
                                reportFiles: 'index.html',
                                reportName: 'JaCoCo Coverage Report'
                            ])
                        }
                    }
                }
            }
        }
        
        stage('üõ°Ô∏è Security Scanning') {
            when {
                not { params.SKIP_SECURITY_SCAN }
            }
            parallel {
                stage('Snyk Dependency Scan') {
                    steps {
                        script {
                            echo "üõ°Ô∏è Running Snyk dependency scan..."
                            
                            try {
                                withCredentials([string(credentialsId: 'snyk-token', variable: 'SNYK_TOKEN')]) {
                                    sh '''
                                        # Install Snyk if not available
                                        if ! command -v snyk &> /dev/null; then
                                            npm install -g snyk
                                        fi
                                        
                                        # Authenticate and scan
                                        snyk auth $SNYK_TOKEN
                                        snyk test --severity-threshold=medium --json > snyk-results.json || true
                                        snyk monitor || true
                                    '''
                                }
                            } catch (Exception e) {
                                echo "‚ö†Ô∏è Snyk scan skipped: ${e.getMessage()}"
                            }
                        }
                    }
                }
                
                stage('OWASP Dependency Check') {
                    steps {
                        script {
                            echo "üîç Running OWASP Dependency Check..."
                            
                            try {
                                sh 'mvn org.owasp:dependency-check-maven:check'
                            } catch (Exception e) {
                                echo "‚ö†Ô∏è OWASP scan completed with findings: ${e.getMessage()}"
                            }
                        }
                    }
                    post {
                        always {
                            // Publish OWASP report
                            publishHTML([
                                allowMissing: true,
                                alwaysLinkToLastBuild: true,
                                keepAll: true,
                                reportDir: 'target',
                                reportFiles: 'dependency-check-report.html',
                                reportName: 'OWASP Dependency Check Report'
                            ])
                        }
                    }
                }
            }
        }
        
        stage('üê≥ Docker Build & Push') {
            steps {
                script {
                    echo "üê≥ Building and pushing Docker image..."
                    
                    withCredentials([aws(credentialsId: 'aws-credentials')]) {
                        // Login to ECR
                        sh """
                            aws ecr get-login-password --region ${AWS_DEFAULT_REGION} | \
                            docker login --username AWS --password-stdin ${ECR_REGISTRY}
                        """
                        
                        // Build multi-architecture image
                        sh """
                            # Build for multiple architectures
                            docker buildx create --use --name multi-arch-builder || true
                            docker buildx build \
                                --platform linux/amd64,linux/arm64 \
                                --build-arg VERSION=${APP_VERSION} \
                                --build-arg BUILD_DATE=\$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
                                --build-arg VCS_REF=${GIT_COMMIT_SHORT} \
                                -t ${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG} \
                                -t ${ECR_REGISTRY}/${ECR_REPOSITORY}:latest \
                                --push .
                        """
                        
                        // Security scan of the built image
                        try {
                            withCredentials([string(credentialsId: 'snyk-token', variable: 'SNYK_TOKEN')]) {
                                sh """
                                    snyk auth $SNYK_TOKEN
                                    snyk container test ${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG} \
                                        --severity-threshold=medium || true
                                """
                            }
                        } catch (Exception e) {
                            echo "‚ö†Ô∏è Container security scan skipped: ${e.getMessage()}"
                        }
                    }
                }
            }
        }
        
        stage('üöÄ Deploy to EKS') {
            steps {
                script {
                    echo "üöÄ Deploying to EKS via ArgoCD..."
                    
                    // Determine namespace based on environment
                    def namespace = params.DEPLOY_ENVIRONMENT == 'production' ? K8S_NAMESPACE_PROD : K8S_NAMESPACE_DEV
                    def appName = params.DEPLOY_ENVIRONMENT == 'production' ? 'eks-products-prod' : 'eks-products-dev'
                    
                    withCredentials([
                        aws(credentialsId: 'aws-credentials'),
                        file(credentialsId: 'kubeconfig', variable: 'KUBECONFIG')
                    ]) {
                        // Update kubeconfig
                        sh "aws eks update-kubeconfig --region ${AWS_DEFAULT_REGION} --name ${K8S_CLUSTER_NAME}"
                        
                        // Update image tag in ArgoCD application
                        sh """
                            # Update image tag in values file or use ArgoCD image updater
                            kubectl patch application ${appName} -n ${ARGOCD_NAMESPACE} --type merge -p '{
                                "spec": {
                                    "source": {
                                        "helm": {
                                            "parameters": [
                                                {
                                                    "name": "image.tag",
                                                    "value": "${IMAGE_TAG}"
                                                }
                                            ]
                                        }
                                    }
                                }
                            }'
                        """
                        
                        // Trigger ArgoCD sync
                        try {
                            withCredentials([string(credentialsId: 'argocd-auth-token', variable: 'ARGOCD_AUTH_TOKEN')]) {
                                sh """
                                    # Install ArgoCD CLI if not available
                                    if ! command -v argocd &> /dev/null; then
                                        curl -sSL -o /tmp/argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
                                        chmod +x /tmp/argocd
                                        sudo mv /tmp/argocd /usr/local/bin/argocd
                                    fi
                                    
                                    # Login and sync
                                    argocd login ${ARGOCD_SERVER} --auth-token=$ARGOCD_AUTH_TOKEN --insecure
                                    argocd app sync ${appName}
                                    argocd app wait ${appName} --timeout 300
                                """
                            }
                        } catch (Exception e) {
                            echo "‚ö†Ô∏è ArgoCD sync via CLI failed, using kubectl: ${e.getMessage()}"
                            
                            // Fallback: trigger sync via kubectl
                            sh """
                                kubectl patch application ${appName} -n ${ARGOCD_NAMESPACE} --type merge -p '{
                                    "operation": {
                                        "sync": {
                                            "revision": "HEAD"
                                        }
                                    }
                                }'
                            """
                        }
                    }
                }
            }
        }
        
        stage('üè• Health Check & Smoke Tests') {
            steps {
                script {
                    echo "üè• Running health checks and smoke tests..."
                    
                    def namespace = params.DEPLOY_ENVIRONMENT == 'production' ? K8S_NAMESPACE_PROD : K8S_NAMESPACE_DEV
                    def serviceName = "${APP_NAME}-service"
                    
                    withCredentials([file(credentialsId: 'kubeconfig', variable: 'KUBECONFIG')]) {
                        // Wait for deployment to be ready
                        sh """
                            kubectl wait --for=condition=available deployment/${APP_NAME} \
                                -n ${namespace} --timeout=300s
                        """
                        
                        // Get service endpoint
                        def serviceEndpoint = sh(
                            script: "kubectl get svc ${serviceName} -n ${namespace} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}'",
                            returnStdout: true
                        ).trim()
                        
                        if (serviceEndpoint) {
                            echo "üåê Service endpoint: http://${serviceEndpoint}"
                            
                            // Health check with retry
                            retry(5) {
                                sh """
                                    sleep 30
                                    curl -f http://${serviceEndpoint}/actuator/health || \
                                    curl -f http://${serviceEndpoint}/health || \
                                    curl -f http://${serviceEndpoint}/
                                """
                            }
                            
                            echo "‚úÖ Health check passed!"
                            
                            // Store endpoint for notifications
                            env.SERVICE_ENDPOINT = "http://${serviceEndpoint}"
                        } else {
                            echo "‚ö†Ô∏è Service endpoint not available yet"
                        }
                    }
                }
            }
        }
    }
    
    post {
        always {
            echo "üßπ Cleaning up workspace..."
            cleanWs()
        }
        
        success {
            script {
                echo "‚úÖ Pipeline completed successfully!"
                
                // Send success notification
                try {
                    withCredentials([string(credentialsId: 'slack-webhook', variable: 'SLACK_WEBHOOK')]) {
                        slackSend(
                            channel: '#jenkins-notifications',
                            color: 'good',
                            message: """
                            ‚úÖ *EKS Products Pipeline - SUCCESS*
                            
                            *Branch:* ${BRANCH_NAME}
                            *Environment:* ${params.DEPLOY_ENVIRONMENT}
                            *Build:* ${BUILD_NUMBER}
                            *Commit:* ${GIT_COMMIT_SHORT}
                            *Image:* ${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}
                            ${env.SERVICE_ENDPOINT ? "*Service:* ${env.SERVICE_ENDPOINT}" : ""}
                            
                            *Duration:* ${currentBuild.durationString}
                            *Jenkins:* ${BUILD_URL}
                            """.stripIndent(),
                            teamDomain: 'your-workspace',
                            token: SLACK_WEBHOOK
                        )
                    }
                } catch (Exception e) {
                    echo "‚ö†Ô∏è Slack notification failed: ${e.getMessage()}"
                }
            }
        }
        
        failure {
            script {
                echo "‚ùå Pipeline failed!"
                
                // Send failure notification
                try {
                    withCredentials([string(credentialsId: 'slack-webhook', variable: 'SLACK_WEBHOOK')]) {
                        slackSend(
                            channel: '#jenkins-notifications',
                            color: 'danger',
                            message: """
                            ‚ùå *EKS Products Pipeline - FAILED*
                            
                            *Branch:* ${BRANCH_NAME}
                            *Environment:* ${params.DEPLOY_ENVIRONMENT}
                            *Build:* ${BUILD_NUMBER}
                            *Commit:* ${GIT_COMMIT_SHORT}
                            *Stage:* ${env.STAGE_NAME ?: 'Unknown'}
                            
                            *Duration:* ${currentBuild.durationString}
                            *Jenkins:* ${BUILD_URL}
                            
                            Please check the logs for details.
                            """.stripIndent(),
                            teamDomain: 'your-workspace',
                            token: SLACK_WEBHOOK
                        )
                    }
                } catch (Exception e) {
                    echo "‚ö†Ô∏è Slack notification failed: ${e.getMessage()}"
                }
            }
        }
        
        unstable {
            echo "‚ö†Ô∏è Pipeline completed with warnings"
        }
        
        aborted {
            echo "üõë Pipeline was aborted"
        }
    }
}
